import { existsSync, readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import { BridgeFileConfig, BridgeTool } from '../types.js';

const START_MARKER = '<!-- DONTREADME:START -->';
const END_MARKER = '<!-- DONTREADME:END -->';

const BRIDGE_CONTENT = `${START_MARKER}
# Codebase Context (auto-generated by dontreadme)
This project has machine-readable context in \`.dontreadme/\`.
- Read \`.dontreadme/understanding.md\` for what this codebase does
- Read \`.dontreadme/architecture.json\` for component structure
- Read \`.dontreadme/api-surface.json\` for routes and exports
- Read \`.dontreadme/risk-profile.json\` for security-sensitive areas
- Read \`.dontreadme/contracts/intent.yml\` for behavioral contracts
${END_MARKER}`;

const BRIDGE_CONFIGS: BridgeFileConfig[] = [
  { tool: 'claude-code', filenames: ['CLAUDE.md'] },
  { tool: 'cursor', filenames: ['.cursorrules', '.cursor/rules'] },
  { tool: 'copilot', filenames: ['.github/copilot-instructions.md'] },
  { tool: 'windsurf', filenames: ['.windsurfrules'] },
  { tool: 'codex', filenames: ['AGENTS.md'] },
];

/**
 * Detect which AI tool config files exist in the project.
 */
export function detectBridgeFiles(cwd: string): Array<{ tool: BridgeTool; path: string }> {
  const found: Array<{ tool: BridgeTool; path: string }> = [];

  for (const config of BRIDGE_CONFIGS) {
    for (const filename of config.filenames) {
      const fullPath = join(cwd, filename);
      if (existsSync(fullPath)) {
        found.push({ tool: config.tool, path: fullPath });
        break; // Only first match per tool
      }
    }
  }

  return found;
}

/**
 * Check if a file already has the dontreadme bridge block.
 */
export function hasBridgeBlock(filePath: string): boolean {
  if (!existsSync(filePath)) return false;
  const content = readFileSync(filePath, 'utf-8');
  return content.includes(START_MARKER);
}

/**
 * Inject or update the bridge block in a file.
 * Never overwrites user content - only appends or updates the marked block.
 */
export function injectBridgeBlock(filePath: string): void {
  if (!existsSync(filePath)) return;

  const content = readFileSync(filePath, 'utf-8');

  if (content.includes(START_MARKER)) {
    // Update existing block
    const startIdx = content.indexOf(START_MARKER);
    const endIdx = content.indexOf(END_MARKER);
    if (startIdx === -1 || endIdx === -1) return;

    const before = content.slice(0, startIdx);
    const after = content.slice(endIdx + END_MARKER.length);
    writeFileSync(filePath, before + BRIDGE_CONTENT + after, 'utf-8');
  } else {
    // Append new block
    const separator = content.endsWith('\n') ? '\n' : '\n\n';
    writeFileSync(filePath, content + separator + BRIDGE_CONTENT + '\n', 'utf-8');
  }
}

/**
 * Remove the bridge block from a file.
 */
export function removeBridgeBlock(filePath: string): void {
  if (!existsSync(filePath)) return;

  const content = readFileSync(filePath, 'utf-8');
  const startIdx = content.indexOf(START_MARKER);
  const endIdx = content.indexOf(END_MARKER);

  if (startIdx === -1 || endIdx === -1) return;

  const before = content.slice(0, startIdx);
  const after = content.slice(endIdx + END_MARKER.length);

  // Clean up extra newlines
  const cleaned = (before + after).replace(/\n{3,}/g, '\n\n').trimEnd() + '\n';
  writeFileSync(filePath, cleaned, 'utf-8');
}

/**
 * Get a summary of what bridge files would be modified.
 */
export function getBridgeSummary(cwd: string): Array<{ tool: BridgeTool; file: string; action: 'inject' | 'update' }> {
  const detected = detectBridgeFiles(cwd);
  return detected.map(({ tool, path }) => ({
    tool,
    file: path.replace(cwd + '/', ''),
    action: hasBridgeBlock(path) ? 'update' as const : 'inject' as const,
  }));
}

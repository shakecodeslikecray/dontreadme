import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import YAML from 'yaml';
import { Manifest, ManifestArtifact } from '../types.js';
import { AnalysisResults } from '../analyzers/index.js';
import { stableStringify, hashContent } from '../core/utils.js';
import { generatePlaceholderUnderstanding } from '../analyzers/understanding.js';
import { generatePlaceholderContracts } from '../analyzers/contracts.js';
import { detectFramework, detectLanguage } from '../core/file-discovery.js';

const DONTREADME_README = `# .dontreadme/

> Machine-readable codebase context for AI tools.

This directory was generated by [dontreadme](https://github.com/shakecodeslikecray/dontreadme).
It contains structured artifacts that help AI coding tools understand your codebase.

## Format

| File | Description |
|------|-------------|
| \`manifest.json\` | Version, generator, timestamps, artifact index |
| \`understanding.md\` | What this codebase does (human+AI readable) |
| \`architecture.json\` | Components, boundaries, data flow |
| \`contracts/intent.yml\` | Behavioral contracts (structured YAML) |
| \`decisions/index.json\` | Decision log from git history |
| \`risk-profile.json\` | Risk assessment by domain |
| \`hotspots.json\` | Bug-prone files (git frequency analysis) |
| \`dependency-graph.json\` | Internal module dependency graph |
| \`api-surface.json\` | Public API surface (routes, exports, endpoints) |

## Regenerate

\`\`\`bash
dontreadme generate        # Regenerate all artifacts
dontreadme generate --only arch,api  # Regenerate specific ones
dontreadme validate        # Validate against schemas
\`\`\`

## Standard

The \`.dontreadme/\` format is an open standard. Any tool can read these files.
See the [specification](https://github.com/shakecodeslikecray/dontreadme) for details.
`;

interface WriteOptions {
  cwd: string;
  results: AnalysisResults;
  files: string[];
  version: string;
}

export function writeAllArtifacts(options: WriteOptions): Manifest {
  const { cwd, results, files, version } = options;
  const dontreadmePath = join(cwd, '.dontreadme');
  const now = new Date().toISOString();
  const artifacts: ManifestArtifact[] = [];

  // Ensure directories exist
  mkdirSync(join(dontreadmePath, 'contracts'), { recursive: true });
  mkdirSync(join(dontreadmePath, 'decisions'), { recursive: true });

  // Write README.md
  writeFileSync(join(dontreadmePath, 'README.md'), DONTREADME_README, 'utf-8');

  // Write architecture.json
  const archContent = stableStringify(results.architecture.data);
  writeFileSync(join(dontreadmePath, 'architecture.json'), archContent, 'utf-8');
  artifacts.push({
    name: 'architecture',
    path: 'architecture.json',
    hash: hashContent(archContent),
    generatedAt: now,
    analyzer: 'architecture',
    deterministic: true,
  });

  // Write dependency-graph.json
  const depContent = stableStringify(results['dependency-graph'].data);
  writeFileSync(join(dontreadmePath, 'dependency-graph.json'), depContent, 'utf-8');
  artifacts.push({
    name: 'dependency-graph',
    path: 'dependency-graph.json',
    hash: hashContent(depContent),
    generatedAt: now,
    analyzer: 'dependency-graph',
    deterministic: true,
  });

  // Write api-surface.json
  const apiContent = stableStringify(results['api-surface'].data);
  writeFileSync(join(dontreadmePath, 'api-surface.json'), apiContent, 'utf-8');
  artifacts.push({
    name: 'api-surface',
    path: 'api-surface.json',
    hash: hashContent(apiContent),
    generatedAt: now,
    analyzer: 'api-surface',
    deterministic: true,
  });

  // Write decisions/index.json
  const decisionsContent = stableStringify(results.decisions.data);
  writeFileSync(join(dontreadmePath, 'decisions', 'index.json'), decisionsContent, 'utf-8');
  artifacts.push({
    name: 'decisions',
    path: 'decisions/index.json',
    hash: hashContent(decisionsContent),
    generatedAt: now,
    analyzer: 'decisions',
    deterministic: true,
  });

  // Write hotspots.json
  const hotspotsContent = stableStringify(results.hotspots.data);
  writeFileSync(join(dontreadmePath, 'hotspots.json'), hotspotsContent, 'utf-8');
  artifacts.push({
    name: 'hotspots',
    path: 'hotspots.json',
    hash: hashContent(hotspotsContent),
    generatedAt: now,
    analyzer: 'hotspots',
    deterministic: true,
  });

  // Write risk-profile.json
  const riskContent = stableStringify(results['risk-profile'].data);
  writeFileSync(join(dontreadmePath, 'risk-profile.json'), riskContent, 'utf-8');
  artifacts.push({
    name: 'risk-profile',
    path: 'risk-profile.json',
    hash: hashContent(riskContent),
    generatedAt: now,
    analyzer: 'risk-profile',
    deterministic: true,
  });

  // Write understanding.md (placeholder or LLM-generated)
  const projectName = cwd.split('/').pop() || 'project';
  const framework = detectFramework(cwd);
  const language = detectLanguage(files);
  const understandingContent = generatePlaceholderUnderstanding(projectName, framework, language, files.length);
  writeFileSync(join(dontreadmePath, 'understanding.md'), understandingContent, 'utf-8');
  artifacts.push({
    name: 'understanding',
    path: 'understanding.md',
    hash: hashContent(understandingContent),
    generatedAt: now,
    analyzer: 'understanding',
    deterministic: false,
  });

  // Write contracts/intent.yml (placeholder or LLM-generated)
  const contractsContent = generatePlaceholderContracts();
  writeFileSync(join(dontreadmePath, 'contracts', 'intent.yml'), contractsContent, 'utf-8');
  artifacts.push({
    name: 'contracts',
    path: 'contracts/intent.yml',
    hash: hashContent(contractsContent),
    generatedAt: now,
    analyzer: 'contracts',
    deterministic: false,
  });

  // Sort artifacts by name for deterministic output
  artifacts.sort((a, b) => a.name.localeCompare(b.name));

  // Write manifest.json
  const manifest: Manifest = {
    version: '1',
    generator: 'dontreadme',
    generatorVersion: version,
    generatedAt: now,
    codebaseRoot: cwd,
    artifacts,
  };

  writeFileSync(join(dontreadmePath, 'manifest.json'), stableStringify(manifest), 'utf-8');

  return manifest;
}
